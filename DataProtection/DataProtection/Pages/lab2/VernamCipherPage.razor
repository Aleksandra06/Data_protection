@using DataProtection.PageModels
@using DataProtection.PageModels.lab2
@using DataProtection.Engine.Managers
@using System
@using System.Collections

@inject IJSRuntime JS

<h3>Шифр Вермана</h3>

@if (goodPrint && Document?.Data != null) {
    <div class="row pb-4">
        <button class="btn btn-nav" @onclick="@Encrypt">Зашифровать</button>
        @*@if (EncodeShamirDocument?.Data != null) {
                <label>Размер: @(EncodeShamirDocument.Data.Length / 2048.00) мб</label>
                <button class="btn btn-nav" @onclick="@(() => DownloadFile(EncodeShamirDocument))">Скачать</button>
            }*@
        @if (goodEncode) {
            <span>
                good
            </span>
        }
    </div>

    <div class="row pb-4">
        <button class="btn btn-nav" @onclick="@Decode">Дешифровать</button>
        @if (DecodeVermanDocument?.Data != null) {
            <label>Размер: @(DecodeVermanDocument.Data.Length / 2048.00) мб</label>
            <button class="btn btn-nav" @onclick="@(() => DownloadFile(DecodeVermanDocument))" style="width: 100px">Скачать</button>
        }
    </div>
}

@if (Document?.Data != null) {
    <div>
        <button class="btn btn-nav" @onclick="@generate">Генерация</button>
    </div>
}


@code {

    [Parameter] public DocumentModel Document { get; set; }
    public DocumentModel DecodeVermanDocument { get; set; }
    public VermanModel Verman = new VermanModel();
    bool goodPrint = false, goodEncode = false;

    public void generate()
    {
        Random random = new Random();
        Verman.Message = new VermanMessage[Document.Data.Length];
        for (int i = 0; i < Verman.Message.Length; i++) {
            Verman.Message[i].k = (byte)random.Next(1, 1 << 8);
        }
        goodPrint = true;
    }

    public void Encrypt()
    {
        byte[] Byte = new byte[1];
        for (int i = 0; i < Document.Data.Length; i++) {

            Byte[0] = Verman.Message[i].k;
            BitArray k = new BitArray(Byte);

            Byte[0] = Document.Data[i];
            BitArray m = new BitArray(Byte);

            Verman.Message[i].e = (byte)getIntFromBitArray(m.Xor(k));
        }
        goodEncode = true;
    }

    public void Decode()
    {
        DecodeVermanDocument = new DocumentModel();
        DecodeVermanDocument.FileName = "Verman_decode_" + Document.FileName;
        DecodeVermanDocument.ContentType = Document.ContentType;
        DecodeVermanDocument.Data = new byte[Document.Data.Length];
        byte[] Byte = new byte[1];
        for (int i = 0; i < Verman.Message.Length; i++) {
            Byte[0] = Verman.Message[i].k;
            BitArray k = new BitArray(Byte);
            Byte[0] = Verman.Message[i].m;
            BitArray m = new BitArray(Byte);
            Byte[0] = Verman.Message[i].e;
            BitArray e = new BitArray(Byte);

            DecodeVermanDocument.Data[i] = (byte)getIntFromBitArray(e.Xor(k));
        }
    }

    private int getIntFromBitArray(BitArray bitArray)
    {

        if (bitArray.Length > 32)
            throw new ArgumentException("Argument length shall be at most 32 bits.");

        int[] array = new int[1];
        bitArray.CopyTo(array, 0);
        return array[0];

    }

    private async void DownloadFile(DocumentModel doc)
    {
        if (doc != null) {
            await JS.InvokeAsync<object>(
                "saveAsFile",
                doc.FileName,
                doc.Data);
        }
    }
}
