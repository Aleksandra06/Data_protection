@using DataProtection.PageModels.Lab1
@using DataProtection.Engine
<h5>Функция, которая решает задачу нахождения дискретного логарифма при помощи алгоритма "Шаг младенца, шаг великана"</h5>
<br>
<h6>Трудоемкость работы функции должна соответствовать описанной в учебнике и составлять O(p * log (p))</h6>

<img src="images/PowerMod.PNG" width="200px" />


<EditForm Model="myLog">
    <div style="margin-left: 105px">X</div>
    <InputNumber @bind-Value="@myLog.a" id="number_a" Class="form-control little-form" style="width: 100px; float: left;" min="1" max="999999999"></InputNumber>
    <span style="margin-left: 20px; margin-right: 10px; float: left;">mod</span>
    <InputNumber @bind-Value="@myLog.p" id="number_p" Class="form-control little-form" style="width: 100px; float: left;" min="1" max="999999999"></InputNumber>
    <span style="margin-left: 10px; margin-right: 10px; float: left;"> = </span>
    <InputNumber @bind-Value="@myLog.y" id="number_y" Class="form-control little-form" style="width: 100px; float: left;" min="1" max="999999999"></InputNumber>
    <button @onclick="@calculator" class="btn btn-nav" style="float: left; margin-left: 10px;">Вычислить</button><br><br>
    <div class="row pb-1">
        <label for="number_m" class="pr-2">m = </label>
        <InputNumber @bind-Value="@myLog.m" id="number_m" Class="form-control little-form" style="width: 100px;" min="1" max="999999999"></InputNumber>
    </div>
    <div class="row pb-1">
        <label for="number_k" class="pr-2">k  = </label>
        <InputNumber @bind-Value="@myLog.k" Class="form-control little-form" id="number_k" style="width: 100px" min="1" max="999999999"></InputNumber>
    </div>

    <button @onclick="@generateRandom" class="btn btn-nav" style="float: left; margin-left: 10px;">Сгенерировать</button><br><br>
    <div class="row pb-1">
        <label class="pr-2">Проверка: </label>
        <div class="form-control little-form" style="width: 400px">
            @check = @iBaby * @myLog.m - @jGiant
        </div>
    </div>
    <div class="row pb-1">
        <label class="pr-2">Проверка: </label>
        <div class="form-control little-form" style="width: 400px">
           @hardPractice = @hardTeory   
        </div>
    </div>

    @if (!mIsShowTable) {
        <button class="btn btn-nav" @onclick="@(() => { mIsShowTable = true; StateHasChanged(); })">Показать таблицу</button>
    } else {
        <div>
            <button class="btn btn-nav" @onclick="@(() => { mIsShowTable = false; StateHasChanged(); })">Спрятать таблицу</button>
        </div>
        <table style="float: left;">
            <thead>
                <tr>
                    <td>
                        Шаг
                    </td>
                    <td>
                        Малыш
                    </td>
                </tr>
            </thead>
            <tbody>
                @for (long i = 0; i < myLog.m; i++) {
                    <tr>
                        <td style="width: 100px">@i</td>
                        <td style="width: 100px">@stepBabyShow[i]</td>
                        <td style="width: 100px">@stepBaby.value[i]</td>
                        @*<td style="width: 100px">@stepBaby.value[stepBaby.index[i]]</td>
                            <td style="width: 100px">@stepBaby.index[i]</td>*@
                    </tr>
                }
            </tbody>
        </table>
        <table>
            <thead>
                <tr>
                    <td>
                        Шаг
                    </td>
                    <td>
                        Гигант
                    </td>
                </tr>
            </thead>
            <tbody>
                @for (long i = 1; i <= myLog.k; i++) {
                    <tr>
                        <td style="width: 100px">@i</td>
                        <td style="width: 100px">@stepGiant[i]</td>
                    </tr>
                }
            </tbody>
        </table>
    }

</EditForm>

@code {
    DisLog myLog { get; set; } = new DisLog();
    MyModPow Power { get; set; } = new MyModPow();
    long check;
    struct StepBaby
    {
        public long[] value;
        public long[] index;
    };
    StepBaby stepBaby = new StepBaby();
    bool mIsShowTable = false;

    long[] stepBabyShow;
    long[] stepGiant;
    long[] index;
    long iBaby = -1, jGiant = -1;
    int MAX = 1000000000;
    long hardPractice = 0, hardTeory = 0;

    void calculator()
    {
        if (myLog.a < 1 || myLog.p < 1 || myLog.y < 1 || myLog.m < 1 || myLog.k < 1)
        {
            return;
        }

        bool flagOnOne = false;
        int k = 1000;
        int i = 0;

        long    tmp_m = myLog.m,
                tmp_k = myLog.k;

        stepBG(myLog.a, myLog.y, myLog.p, tmp_m, tmp_k);
        //while ((iBaby == -1 || jGiant == -1) && i < k)
        //{
        //    if (tmp_m == tmp_k) {
        //        if (!flagOnOne) {
        //            tmp_m++;
        //            flagOnOne = true;
        //        } else {
        //            tmp_k++;
        //            flagOnOne = false;
        //        }
        //    } else if (tmp_m > tmp_k) {
        //        tmp_k++;
        //    } else if (tmp_m < tmp_k) {
        //        tmp_m++;
        //    }
        //    stepBG(myLog.a, myLog.y, myLog.p, tmp_m, tmp_k);
        //    i++;
        //}

        myLog.k = tmp_k;
        myLog.m = tmp_m;

        hardTeory = (long)(Math.Sqrt(myLog.p) * Math.Pow(Math.Log2(myLog.p), 2));

        StateHasChanged();
    }

    public long stepBG(long a, long y, long p, long m, long k)
    {
        hardPractice = 0; hardTeory = 0;
        stepBaby.value = new long[m];
        stepBaby.index = new long[m];

        stepBabyShow = new long[m];
        stepGiant = new long[k + 1];
        index = new long[m];

        for (int i = 0; i < m; i++)
        {
            index[i] = i;
            stepBaby.index[i] = i;
        }

        stepBaby.value[0] = stepBabyShow[0] = y;
        for (long i = 1; i < m; i++)
        {
            stepBaby.value[i] = (Power.Pow(a, i, p) * y) % p;
            stepBabyShow[i] = stepBaby.value[i];
        }

        sorting(stepBaby, 0, m - 1);


        stepGiant[0] = 1;
        for (long i = 1; i <= k; i++)
        {
            stepGiant[i] = Power.Pow(a, i * m, p);
            iBaby = binSearch(stepBaby, stepGiant[i], 0, m);
            if (iBaby > -1)
            {
                jGiant = i;
                break;
            }
        }
        check = iBaby * m - jGiant;
        return check;
    }

    public void generateRandom()
    {
        var rand = new Random();
        myLog.a = rand.Next(2, MAX);

        int currentP;
        do
        {
            currentP = rand.Next(2, MAX);
        } while (!isPrime(currentP));
        myLog.p = currentP;

        int currentY;
        do
        {
            currentY = rand.Next(1, MAX);
        } while (currentY >= myLog.p);
        myLog.y = currentY;

        myLog.m = (long)Math.Ceiling(Math.Sqrt((double)myLog.p));
        myLog.k = myLog.m;
    }

    bool isPrime(long p)
    {
        if (p <= 1) return false;

        int b = (int)Math.Pow(p, 0.5);

        for (int i = 2; i <= b; ++i)
        {
            if ((p % i) == 0) return false;
        }

        return true;
    }

    void sorting(StepBaby arr, long first, long last)
    {
        long p = arr.value[(last - first) / 2 + first];
        long temp;
        long i = first, j = last;
        while (i <= j)
        {
            while (arr.value[i] < p && i <= last) ++i;
            while (arr.value[j] > p && j >= first) --j;
            hardPractice++;
            if (i <= j)
            {
                temp = arr.index[i];
                arr.index[i] = arr.index[j];
                arr.index[j] = temp;
                hardPractice+=6;
                temp = arr.value[i];
                arr.value[i] = arr.value[j];
                arr.value[j] = temp;
                ++i; --j;
            }
        }
        hardPractice++;
        if (j > first) sorting(arr, first, j);
        hardPractice++;
        if (i < last) sorting(arr, i, last);
    }

    long binSearch(StepBaby array, long searchedValue, long left, long right)
    {
        while (left < right)
        {
            long middle = (left + right) / 2;
            hardPractice++;
            if (searchedValue == array.value[middle])
            {
                return array.index[middle];
            }
            else if (searchedValue < array.value[middle])
            {
                right = middle - 1;
            }
            else
            {
                left = middle + 1;
            }
        }
        return -1;
    }
}
